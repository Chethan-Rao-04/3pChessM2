name: CI-CD

on: [push, pull_request]

jobs:
  build:
    runs-on: ubuntu-latest
    environment: Dev

    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      - name: Set up JDK
        uses: actions/setup-java@v1
        with:
          java-version: '17'

      - name: Build with Gradle
        run: ./gradlew build

      - name: Run tests and generate JaCoCo report
        run: ./gradlew test jacocoTestReport

      - name: Run PMD
        run: ./gradlew pmdMain

      - name: Check PMD report and fail build if violations exist
        run: |
          violations=$(grep -o 'violation' app/build/reports/pmd/main.html | wc -l)
          if [ "$violations" -gt 0 ]; then
            echo "PMD violations detected! Failing the build."
            exit 1
          fi

      - name: Upload PMD report
        uses: actions/upload-artifact@v4
        with:
          name: pmd-report
          path: app/build/reports/pmd

      - name: Upload JaCoCo report
        uses: actions/upload-artifact@v4
        with:
          name: jacoco-report
          path: app/build/reports/jacoco/test

      # Add Docker build step
      - name: Build Docker image
        run: |
          docker build -t chethancn/3pchess:${{ github.sha }} .

      # Log in to Docker Hub
      - name: Log in to Docker Hub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      # Tag and push Docker image
      - name: Tag Docker image
        run: |
          docker tag chethancn/3pchess:${{ github.sha }} chethancn/3pchess:latest

      - name: Push Docker image
        run: |
          docker push chethancn/3pchess:${{ github.sha }}
          docker push chethancn/3pchess:latest

      # Set up kubectl
      - name: Set up kubectl
        uses: azure/setup-kubectl@v3
        
      # Configure kubectl with your kubeconfig
      - name: Configure kubectl
        run: |
          mkdir -p $HOME/.kube
          echo "${{ secrets.KUBE_CONFIG }}" > $HOME/.kube/config
          chmod 600 $HOME/.kube/config
          
      # Update kubernetes deployment image
      - name: Update deployment image
        run: |
          # Update the image tag in deployment file
          sed -i "s|image: chethancn/3pchess.*|image: chethancn/3pchess:${{ github.sha }}|" Kubernetes/3pchess.deployment.yaml
          
      # Deploy to kubernetes
      - name: Deploy to Kubernetes
        run: |
          kubectl apply --validate=false -f Kubernetes/3pchess.deployment.yaml
          kubectl rollout status deployment/chess3player-deployment

  minikube-test:
    needs: build
    runs-on: ubuntu-latest
    environment: Dev

    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      - name: Install prerequisites
        run: |
          # Update package list
          sudo apt-get update
          
          # Install required packages
          sudo apt-get install -y conntrack socat
          
          # Verify Docker installation
          docker version
          docker info
          
          # Create required directories
          sudo mkdir -p /usr/local/bin/
          
      - name: Install kubectl
        run: |
          curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
          sudo install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl
          kubectl version --client

      - name: Install Minikube
        run: |
          # Download Minikube
          curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64
          
          # Install Minikube
          sudo install minikube-linux-amd64 /usr/local/bin/minikube
          rm minikube-linux-amd64
          
          # Verify installation
          minikube version
          
          # Set Minikube permissions
          sudo chmod +x /usr/local/bin/minikube
          
      - name: Configure Docker for Minikube
        run: |
          # Ensure Docker is running
          sudo systemctl status docker || sudo systemctl start docker
          
          # Add current user to docker group
          sudo usermod -aG docker $USER
          
          # Create docker network for Minikube
          docker network create minikube || true

      - name: Start Minikube
        run: |
          # Function to check Minikube status
          check_minikube_status() {
            minikube status && return 0
            return 1
          }
          
          # Function to start Minikube with retries
          start_minikube() {
            local max_attempts=3
            local attempt=1
            
            while [ $attempt -le $max_attempts ]; do
              echo "Attempt $attempt to start Minikube..."
              
              minikube delete --all --purge || true
              
              minikube start \
                --driver=docker \
                --memory=2048 \
                --cpus=2 \
                --kubernetes-version=stable \
                --wait=all \
                --wait-timeout=5m \
                --delete-on-failure && return 0
              
              echo "Minikube start failed. Collecting logs..."
              minikube logs
              
              attempt=$((attempt + 1))
              [ $attempt -le $max_attempts ] && sleep 30
            done
            
            return 1
          }
          
          # Start Minikube with retry logic
          if ! start_minikube; then
            echo "Failed to start Minikube after multiple attempts"
            exit 1
          fi
          
          # Verify Minikube status
          if ! check_minikube_status; then
            echo "Minikube is not running properly"
            exit 1
          fi
          
          # Display cluster information
          kubectl cluster-info
          
          # Wait for core components with timeout
          timeout 300s bash -c 'until kubectl wait --for=condition=ready pod -l k8s-app=kube-dns -n kube-system --timeout=30s; do echo "Waiting for DNS..."; sleep 5; done'
          
          # Enable metrics-server with verification
          minikube addons enable metrics-server
          timeout 120s bash -c 'until kubectl wait --for=condition=ready pod -l k8s-app=metrics-server -n kube-system --timeout=30s; do echo "Waiting for metrics-server..."; sleep 5; done'
          
          # Verify node status
          kubectl get nodes
          kubectl describe node minikube

      - name: Verify Minikube environment
        run: |
          # Function to check component health
          check_component() {
            local namespace=$1
            local label=$2
            local component=$3
            
            echo "Checking $component..."
            if ! kubectl get pods -n $namespace -l $label; then
              echo "Error: $component pods not found"
              return 1
            fi
            
            if ! kubectl wait --for=condition=ready pod -l $label -n $namespace --timeout=60s; then
              echo "Error: $component not ready"
              return 1
            fi
            
            return 0
          }
          
          # Check core components
          check_component "kube-system" "k8s-app=kube-dns" "CoreDNS" || exit 1
          check_component "kube-system" "k8s-app=metrics-server" "Metrics Server" || exit 1
          
          # Check node health
          if ! kubectl get nodes minikube -o jsonpath='{.status.conditions[?(@.type=="Ready")].status}' | grep -q "True"; then
            echo "Error: Minikube node is not ready"
            kubectl describe node minikube
            exit 1
          fi
          
          # Check available resources
          kubectl describe node minikube | grep -A 5 "Allocated resources"
          
          # Verify API server accessibility
          if ! curl -k --retry 5 --retry-delay 5 --retry-connrefused https://$(minikube ip):8443/version; then
            echo "Error: Cannot access Kubernetes API server"
            exit 1
          fi
          
          echo "Minikube environment verification completed successfully"

      - name: Configure Docker environment
        run: |
          eval $(minikube docker-env)
          docker info

      - name: Build Docker image in Minikube
        run: |
          eval $(minikube docker-env)
          docker build -t chethancn/3pchess:test .
          docker images | grep 3pchess

      - name: Deploy to Minikube
        run: |
          # Update deployment file for testing
          sed -i 's/containerPort: 8080/containerPort: 8090/' Kubernetes/3pchess.deployment.yaml
          kubectl apply -f Kubernetes/3pchess.deployment.yaml
          kubectl rollout status deployment/chess3player-deployment --timeout=180s

      - name: Verify deployment
        run: |
          kubectl wait --for=condition=ready pod -l app=chess3player --timeout=180s
          kubectl get pods -l app=chess3player -o wide
          kubectl get services chess3player-service
          minikube service chess3player-service --url

      - name: Configure test environment
        run: |
          # Create ConfigMap for test configuration
          cat <<EOF | kubectl apply -f -
          apiVersion: v1
          kind: ConfigMap
          metadata:
            name: chess3player-test-config
          data:
            SPRING_PROFILES_ACTIVE: "test"
            LOG_LEVEL: "DEBUG"
          EOF
          
          # Update deployment to use ConfigMap
          kubectl patch deployment chess3player-deployment --patch '{"spec":{"template":{"spec":{"containers":[{"name":"chess3player","envFrom":[{"configMapRef":{"name":"chess3player-test-config"}}]}]}}}}'
          
          # Wait for updated pods
          kubectl rollout status deployment/chess3player-deployment --timeout=180s

      - name: Monitor resource usage
        run: |
          # Start resource monitoring in background
          kubectl top pods -l app=chess3player --containers > resource_usage_start.txt
          
          # Run tests while monitoring resources
          for i in {1..5}; do
            echo "Resource usage check $i:"
            kubectl top pods -l app=chess3player --containers
            sleep 10
          done > resource_usage_during_tests.txt

      - name: Test API endpoints
        run: |
          # Get service URL
          SERVICE_URL=$(minikube service chess3player-service --url)
          echo "Testing against $SERVICE_URL"
          
          # Test /newGame endpoint
          echo "Testing /newGame endpoint..."
          curl -v -X GET "$SERVICE_URL/newGame"
          
          # Test /board endpoint
          echo "Testing /board endpoint..."
          BOARD_RESPONSE=$(curl -s -X GET "$SERVICE_URL/board")
          if [ -z "$BOARD_RESPONSE" ]; then
            echo "Error: Empty board response"
            exit 1
          fi
          
          # Test /currentPlayer endpoint
          echo "Testing /currentPlayer endpoint..."
          PLAYER_RESPONSE=$(curl -s -X GET "$SERVICE_URL/currentPlayer")
          if [ -z "$PLAYER_RESPONSE" ]; then
            echo "Error: Empty player response"
            exit 1
          fi
          
          # Test /onClick endpoint with a valid move
          echo "Testing /onClick endpoint..."
          curl -v -X POST "$SERVICE_URL/onClick" \
            -H "Content-Type: application/json" \
            -d '"A2"'
          
          # Final health check
          echo "Testing health endpoint..."
          curl -v --retry 5 --retry-delay 5 --retry-connrefused "$SERVICE_URL/actuator/health"

      - name: Collect performance metrics
        if: always()
        run: |
          echo "Resource usage at start:"
          cat resource_usage_start.txt
          
          echo "Resource usage during tests:"
          cat resource_usage_during_tests.txt
          
          echo "Final resource usage:"
          kubectl top pods -l app=chess3player --containers
          
          echo "Pod events:"
          kubectl get events --field-selector involvedObject.kind=Pod
          
          echo "Service endpoints:"
          kubectl get endpoints chess3player-service -o yaml

      - name: Collect logs on failure
        if: failure()
        run: |
          kubectl get pods
          kubectl describe pods
          kubectl logs -l app=chess3player
          minikube logs

      - name: Clean up
        if: always()
        run: |
          minikube delete --all
          docker system prune -af

          